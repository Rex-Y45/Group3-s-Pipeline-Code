import maya.cmds as cmds  # 导入 Maya 命令模块
import os  # 导入操作系统模块，用于文件路径处理

class AssetLoaderTool:
    def __init__(self, shot_name, working_file_directory):
        """
        初始化工具，设置镜头名称和工作文件目录，定义需要加载的资产目录。
        """
        self.shot_name = shot_name  # 存储镜头名称
        self.working_file_directory = working_file_directory  # 存储工作文件的目录路径
        self.assets_to_load = {  # 定义需要加载的资产类型，初始为空
            'set': None,
            'layout_camera': None,
            'character_animation': None,
            'prop_cache': None
        }
        self.current_versions = {}  # 用于存储当前加载的每个资产的版本
        self.platform = os.name  # 检测操作系统平台 ('nt' 表示Windows, 其他为Unix)

    def define_working_file(self):
        """
        定义工作文件的位置，确保工作目录存在。
        """
        if not os.path.exists(self.working_file_directory):  # 检查目录是否存在
            raise FileNotFoundError("工作目录未找到。")  # 如果不存在，抛出异常
        print(f"工作文件已设置为: {self.working_file_directory}")  # 打印确认信息
    
    def get_latest_version(self, asset_type):
        """
        获取给定资产类型的最新版本。
        """
        # 构造资产发布目录路径
        publish_folder = os.path.join(self.working_file_directory, 'publish', asset_type)
        if not os.path.exists(publish_folder):  # 如果发布目录不存在
            raise FileNotFoundError(f"未找到 {asset_type} 的发布目录。")  # 抛出异常

        # 列出发布目录中的所有文件夹（假定版本是通过文件夹区分）
        versions = [f for f in os.listdir(publish_folder) if os.path.isdir(os.path.join(publish_folder, f))]
        if not versions:  # 如果没有找到任何版本文件夹
            raise ValueError(f"未找到 {asset_type} 的版本。")  # 抛出异常
        
        # 对版本进行排序，取最新的版本（假设版本号递增）
        latest_version = sorted(versions)[-1]
        self.current_versions[asset_type] = latest_version  # 更新当前资产的最新版本信息
        print(f"{asset_type} 的最新版本为 {latest_version}")  # 打印最新版本信息
        return os.path.join(publish_folder, latest_version)  # 返回最新版本的完整路径
    
    def load_asset(self, asset_type):
        """
        加载指定类型资产的最新版本。
        """
        latest_version_path = self.get_latest_version(asset_type)  # 获取最新版本的路径
        try:
            cmds.file(latest_version_path, reference=True)  # 使用 Maya 的 cmds.file() 来引用最新的资产文件
            print(f"引用 {asset_type} 的最新版本，路径为: {latest_version_path}")
            self.assets_to_load[asset_type] = latest_version_path  # 更新已加载资产的路径
        except Exception as e:
            print(f"引用 {asset_type} 时出错: {e}")
    
    def check_for_outdated_assets(self):
        """
        检查当前场景中的资产是否是最新的版本。
        """
        loaded_references = cmds.ls(references=True)  # 获取所有引用的资产
        for asset_type, current_version in self.current_versions.items():
            latest_version = self.get_latest_version(asset_type)  # 获取最新版本路径
            for ref in loaded_references:
                ref_file = cmds.referenceQuery(ref, filename=True)  # 获取引用文件路径
                if current_version in ref_file:
                    print(f"{asset_type} 当前是最新版本。")
                else:
                    print(f"{asset_type} 版本过期。当前: {ref_file}, 最新: {latest_version}")
                    # 此处可以添加提示，要求艺术家更新资产或选择回滚
    
    def load_all_assets(self):
        """
        加载所有必需的资产：场景、摄像机、角色动画和道具。
        """
        self.load_asset('set')  # 加载场景
        self.load_asset('layout_camera')  # 加载摄像机布局
        self.load_asset('character_animation')  # 加载角色动画
        self.load_asset('prop_cache')  # 加载道具缓存

    def roll_back_version(self, asset_type, target_version):
        """
        将指定资产回滚到之前的某个版本。
        """
        # 构造目标版本的路径
        publish_folder = os.path.join(self.working_file_directory, 'publish', asset_type)
        target_version_path = os.path.join(publish_folder, target_version)
        if os.path.exists(target_version_path):
            # 首先卸载当前版本
            refs = cmds.ls(references=True)
            for ref in refs:
                if asset_type in ref:
                    cmds.file(ref, removeReference=True)  # 卸载当前引用
            
            # 引用目标版本
            try:
                cmds.file(target_version_path, reference=True)
                print(f"{asset_type} 回滚到版本 {target_version}")
                self.assets_to_load[asset_type] = target_version_path
            except Exception as e:
                print(f"回滚 {asset_type} 时出错: {e}")
        else:
            raise ValueError(f"{asset_type} 的版本 {target_version} 不存在。")
    
    def handle_platform_path(self, path):
        """
        根据操作系统类型调整路径格式，确保兼容性。
        """
        if self.platform == 'nt':  # Windows平台
            return path.replace('/', '\\')  # 替换为 Windows 风格
        else:  # Unix平台 (Linux/Mac)
            return path.replace('\\', '/')  # 替换为 Unix 风格

    def create_ui(self):
        """
        创建工具的用户界面，供艺术家使用。
        """
        if cmds.window("assetLoaderWindow", exists=True):
            cmds.deleteUI("assetLoaderWindow")  # 如果窗口已存在，先删除旧的窗口
        
        window = cmds.window("assetLoaderWindow", title="Asset Loader", widthHeight=(300, 200))  # 创建新窗口
        cmds.columnLayout(adjustableColumn=True)  # 创建列布局
        
        cmds.text(label="选择镜头：")
        cmds.textField("shotNameField", text=self.shot_name)  # 文本框，用于显示镜头名称
        
        cmds.button(label="加载所有资产", command=lambda *args: self.load_all_assets())  # 按钮，用于加载所有资产
        
        cmds.showWindow(window)  # 显示窗口
